---
layout:     post
title:      "leetcode[3] 最长子串"
description: "leetcode[3] 最长子串"
date:     2023-01-14
author: sfeng
categories: ["leetcode", "algorithm"]
tags: ["algorithm"]
URL: "/leetcode/03最长子串/"
---

## 题目描述

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入:s = "abcabcbb"
输出:3
解释: 因为无重复字符的最长子串是"abc"，所以其长度为 3。

```

**示例 2:**

```
输入:s = "bbbbb"
输出:1
解释:因为无重复字符的最长子串是"b"，所以其长度为 1。

```

**示例 3:**

```
输入:s = "pwwkew"
输出:3
解释:因为无重复字符的最长子串是"wke"，所以其长度为 3。
     请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。
```

## 解析

该题最优解可以使用滑动窗口来做，并用 map 来记录字符在字符串中的位置

1、定义滑动窗口左右两个指针，初始值都在字符串最左侧

2、用右指针作为字符串索引来遍历字符串，并用 map 来记录该字符在字符串中的位置

3、判断当前字符是否在 map 中，如果不存在，则将该字符添加到 map 中，key 为当前字符，value 为索引；如果存在，直接将左指针更新为该字符在 map 中的下一位 (这里比较难理解，可以看下面图解)

4、每次刷新窗口时，需要比较窗口长度，来取出最大值

假如输入 abab

![](/img/leetcode03.png)

## 代码

```go
func lengthOfLongestSubstring(s string) int {
	// 初始化 map，key 为当前字符，value 为字符索引
	m := make(map[byte]int)
	// 定义左右指针，最大值
	l, r, max := 0, 0, 0
	// 用右指针做为索引遍历
	for ; r < len(s); r++ {
		// 如果当前字符不存在 map 中，则记录该字符
		if _, ok := m[s[r]]; !ok {
			m[s[r]] = r
		} else {
			// 如果当前字符存在 map 中，需要先判断该字符是否在左指针左边，如果在左边则忽略，如果在右边更新左指针
			if m[s[r]] >= l {
				l = m[s[r]] +1
			}
			// 如果当前字符存在 map 中，更新右指针位置
			m[s[r]] = r
		}
		// 计算子串长度最大值
		if r-l+1 > max {
			max = r - l + 1
		}
	}
	return max
}
```